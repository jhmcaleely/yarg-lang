import("machine");
import("gpio");

var GPIO_IRQ_EDGE_FALL = 0x4;
var GPIO_IRQ_EDGE_RISE = 0x8;
var GPIO_IRQ_CALLBACK_ORDER_PRIORITY = 0d0;
var NUM_BANK0_GPIOS = 0d30;

var IO_IRQ_BANK0 = 0d13;

var callbacks = make_array(0d2);

var IO_BANK0_BASE = 0x40014000;

fun gpio_acknowledge_irq(gpio, events) {
    var register_base = IO_BANK0_BASE;
    register_base = register_base + 0d30 * 0d8;
    var offset = (gpio / 0d8) * 0d4;

    rpoke(register_base + offset, events << (0d4 * (gpio % 0d8)));
}

fun gpio_default_irq_handler() {
    var core = coreNum();
    var callback = callbacks[core];

    var register_base = IO_BANK0_BASE;
    register_base = register_base + 0d30 * 0d8;
    register_base = register_base + 0d4 * 0d4;
    register_base = register_base + core * 0d4 * 0d3 *0d4;
    register_base = register_base + 0d2 * 0d4 * 0d4;

    for (var gpio = 0d0; gpio < NUM_BANK0_GPIOS; gpio= gpio + 0d8) {
        var gpio_bank = gpio >> 0d3;

        var register_location = register_base + gpio_bank * 0d4;

        var events8 = rpeek(register_location);
      
        for(var i = gpio; (events8 != 0d0) and (i < (gpio + 0d8)); i = i + 0d1) {
            var events = events8 & 0xf;
            if (events != 0d0) {
                gpio_acknowledge_irq(i, events);
                if (callback) {
                    callback(i, events);
                }
            }
            events8 = events8 >> 0d4;
        }
    }
}

var gpio_handler_routine = make_routine(gpio_default_irq_handler, true);

fun gpio_set_irq_callback(callback) {
    var core = coreNum();
    if (callbacks[core]) {
        if (!callback) {
            irq_remove_handler(IO_IRQ_BANK0, gpio_handler_routine);
        }
        callbacks[core] = callback;
    } else if (callback) {
        callbacks[core] = callback;
        irq_add_shared_handler(IO_IRQ_BANK0, gpio_handler_routine, GPIO_IRQ_CALLBACK_ORDER_PRIORITY);
    }
}

fun gpio_set_irq_enabled(gpio, events, enabled) {
    gpio_acknowledge_irq(gpio, events);

    events = events << (0d4 * (gpio % 0d8));
    var ctrl = alias_reg(0x40014100);

    if (enabled) {
        ctrl.set(events);
    }
    else {
        ctrl.clr(events);
    }
}

var PPB_BASE = 0xe0000000;
var M0PLUS_NVIC_ISER_OFFSET = 0x0000e100;
var NVIC_ISER_OFFSET = 0x0;
var NVIC_ICER_OFFSET = 0x80;
var NVIC_ISPR_OFFSET = 0x100;
var NVIC_ICPR_OFFSET = 0x180;
var NVIC_HW_BASE = PPB_BASE + M0PLUS_NVIC_ISER_OFFSET;

fun irq_set_mask_n_enabled(n, mask, enabled) {
    if (enabled) {
        rpoke(NVIC_HW_BASE + NVIC_ICPR_OFFSET, mask);
        rpoke(NVIC_HW_BASE + NVIC_ISER_OFFSET, mask);
    } else {
        rpoke(NVIC_HW_BASE + NVIC_ICER_OFFSET, mask);
    }
}

fun irq_set_enabled(bank, enabled) {
    irq_set_mask_n_enabled(bank / 0d32, 0d1 << (bank % 0d32), enabled);
}

fun gpio_set_irq_enabled_with_callback(gpio, events, enabled, callback) {
    gpio_set_irq_callback(callback);
    gpio_set_irq_enabled(gpio, events, enabled);
    if (enabled) {
        irq_set_enabled(IO_IRQ_BANK0, true);
    }
}

var state1 = false;
var gpio_button1 = 0d2;
var gpio_led1 = 0d3;

fun gpio_callback(num, events) {
    state1 = !state1;
    gpio_put(gpio_led1, state1);
}

gpio_init(gpio_led1);
gpio_set_direction(gpio_led1, GPIO_OUT);

gpio_init(gpio_button1);

gpio_set_irq_enabled_with_callback(gpio_button1, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true, gpio_callback);
