import("gpio");
import("machine");

var gpio_watch = 0d2;
var GPIO_IRQ_EDGE_FALL = 0x4;
var GPIO_IRQ_EDGE_RISE = 0x8;

var IO_IRQ_BANK0 = 0d13;

var callbacks = make_array(0d2);

print "Hello GPIO IRQ";

fun gpio_callback() {
    print "hello 2";
}

var IO_BANK0_BASE 0x40014000;

type io_bank0_status_ctrl struct {
    muint32 ro status@0x0;
    muint32 rw ctrl@0d4;
}

type io_bank0_irq_ctrl struct {
    muint32 rw inte[4];
    muint32 rw intf[4];
    muint32 ro ints[4];
}

struct io_bank0_hw@IO_BANK0_BASE {
    io_bank0_status_ctrl io[30];
    muint32 rw intr[4];
    io_bank0_irq_ctrl proc0_irq_ctrl;
    io_bank0_irq_ctrl proc1_irq_ctrl;
    io_bank0_irq_ctrl dormant_wake_irq_ctrl;
}

fun gpio_acknowledge_irq(gpio, events) {
    io_bank0_hw->intr[gpio / 8] = events << (4 * (gpio % 8));
}

fun gpio_default_irq_handler() {
    var core = coreNum();
    var callback = callbacks[core];
    io_bank0_irq_ctrl_hw_t *irq_ctrl_base = core ? &io_bank0_hw->proc1_irq_ctrl : &io_bank0_hw->proc0_irq_ctrl;
    for (gpio = 0; gpio < NUM_BANK0_GPIOS; gpio+=8) {
        uint32_t events8 = irq_ctrl_base->ints[gpio >> 3u];
        // note we assume events8 is 0 for non-existent GPIO
        for(uint i=gpio;events8 && i<gpio+8;i++) {
            uint32_t events = events8 & 0xfu;
            if (events && !(raw_irq_mask[core] & (1ull << i))) {
                gpio_acknowledge_irq(i, events);
                if (callback) {
                    callback(i, events);
                }
            }
            events8 >>= 4;
        }
    }
}

fun gpio_set_irq_callback(callback) {
    var core = coreNum();
    if (callbacks[core]) {
        if (!callback) {
            irq_remove_handler(IO_IRQ_BANK0, gpio_default_irq_handler);
        }
        callbacks[core] = callback;
    } else if (callback) {
        callbacks[core] = callback;
        irq_add_shared_handler(IO_IRQ_BANK0, gpio_default_irq_handler, GPIO_IRQ_CALLBACK_ORDER_PRIORITY);
    }
}

fun gpio_acknowledge_irq(gpio, events) {
    io_bank0_hw.intr[gpio / 8] = events << (4 * (gpio % 8));
}

fun _gpio_set_irq_enabled(gpio, events, enabled, control) {
    gpio_acknowledge_irq(gpio, events);

    io_rw_32 *en_reg = &irq_ctrl_base->inte[gpio / 8];
    events <<= 4 * (gpio % 8);

    if (enabled)
        hw_set_bits(en_reg, events);
    else
        hw_clear_bits(en_reg, events);
}

fun gpio_set_irq_enabled(gpio, events, enabled) {
    var irq_ctrl_base = nil;
    if (coreNum() == 0) {
        irq_ctrl_base = proc0_irq_ctrl;
    } else {
        irq_ctrl_base = proc1_irq_ctrl;
    }

    _gpio_set_irq_enabled(gpio, events, enabled, irq_ctrl_base);
}

var PPB_BASE = 0xe0000000;
var M0PLUS_NVIC_ISER_OFFSET = 0x0000e100;

struct nvic_hw@PPB_BASE + M0PLUS_NVIC_ISER_OFFSET {
    muint32 rw iser@0x0;
    muint32 rw icer@0x8;
    muint32 rw ispr@0x12;
    muint32 rw icpr@0x16;
}

fun irq_set_mask_n_enabled(n, mask, enabled) {
    if (enabled) {
        nvic_hw.icpr = mask;
        nvic_hw.iser = mask;
    } else {
        nvic_hw.icer = mask;
    }
}

fun irq_set_enabled(bank, enabled) {
    irq_set_mask_n_enabled(bank / 0d32, 0d1 << (bank % 0d32), enabled);
}



fun gpio_set_irq_enabled_with_callback(gpio, events, enabled, callback) {
    gpio_set_irq_callback(callback);
    gpio_set_irq_enabled(gpio, events, enabled);
    if (enabled) {
        irq_set_enabled(IO_IRQ_BANK0, true);
    }
}

gpio_init(gpio_watch);
gpio_set_irq_enabled_with_callback(gpio_watch, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true, gpio_callback);
