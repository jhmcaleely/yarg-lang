import("machine");
import("reset");
import("clock");
import("gpio");

place struct {
    uint32 dr;
    uint32 rsr;
    uint32@0x18 fr;
    uint32@0x20 ilpr;
    uint32 ibrd;
    uint32 fbrd;
    uint32 lcr_h;
    uint32 cr;
    uint32 ifls;
    uint32 imsc;
    uint32 ris;
    uint32 mis;
    uint32 icr;
    uint32 dmacr;
    uint32[4]@0xfe0 periphid;
    uint32[4]@0xff0 pcellid;
    } {
        @x40034000 uart0;
        @x40038000 uart1;
    }

const uart = [ uart0, uart1 ];

fun uart_reset(id) {
    reset_block(reset_uart[id]);
}

fun uart_unreset(id) {
    reset_await(reset_uart[id]);
    unreset_block(reset_uart[id]);
}

fun uart_clock_get_hz(id) {
    return uint32(c_clock_get_hz(clock_peri));
}

fun uart_set_baudrate(id, baudrate) {
    uint32 baud_rate_div = (uint32(8) * uart_clock_get_hz(id) / uint32(baudrate)) + uint32(1);
    uint32 baud_ibrd = baud_rate_div >> uint32(7);
    uint32 baud_fbrd;

    if (baud_ibrd == uint32(0)) {
        baud_ibrd = uint32(1);
        baud_fbrd = uint32(0);
    } else if (baud_ibrd >= uint32(65535)) {
        baud_ibrd = uint32(65535);
        baud_fbrd = uint32(0);
    } else {
        baud_fbrd = (baud_rate_div & uint32(0x7f)) >> uint32(1);
    }

    poke uart[id].ibrd, baud_ibrd;
    poke uart[id].fbrd, baud_fbrd;

    // PL011 needs a (dummy) LCR_H write to latch in the divisors.
    // We don't want to actually change LCR_H contents here.    
    reg_write_masked(uart[id].lcr_h, 0, 0);

    return (uint32(4) * uart_clock_get_hz(id)) / (uint32(64) * baud_ibrd + baud_fbrd);
}

const uint32 UART_PARITY_NONE = uint32(0);

fun uart_init(id, baud, fifo_enable) {
    uart_reset(id);
    uart_unreset(id);

    var set_baud = uart_set_baudrate(id, baud);

    uint32 data_bits = uint32(8);
    uint32 stop_bits = uint32(1);
    uint32 parity = UART_PARITY_NONE;

    var FEN = 0x0;
    if (fifo_enable) {
        FEN = 0x10;
    }

    reg_write_masked(uart[id].lcr_h,
                    ((data_bits - uint32(5)) << uint32(5)) |
                    ((stop_bits - uint32(1)) << uint32(3)) |
                    0x0|
                    FEN,
                    0x00000060 | 0x00000008 | 0x00000002 | 0x00000004 | 0x00000010
                    );
    
    poke uart[id].cr, 0x00000001 | 0x00000100 | 0x00000200;
}

const UART_UARTFR_TXFF_BITS = 0x20;
const UART_UARTFR_RXFF_BITS = 0x40;

fun uart_is_writeable(id) {
    return peek(uart[id].fr) & UART_UARTFR_TXFF_BITS != UART_UARTFR_TXFF_BITS;
}

fun uart_is_readable(id) {
    return peek(uart[id].fr) & UART_UARTFR_RXFF_BITS == UART_UARTFR_RXFF_BITS;
}

fun uart_put_byte(id, c) {
    while (!uart_is_writeable(id)) {
    }
    poke uart[id].dr, uint32(c) & 0xff;
}

fun uart_get_byte(id) {
    while (!uart_is_readable(id)) {
    }
    return uint8(peek(uart[id].dr) & 0xff);
}
