import("machine");
import("irq");

const pico_led = 0d25;

const GPIO_OUT = true;
const GPIO_IN = false;

const gpio_func_ixp = 0d0;
const gpio_func_spi = 0d1;
const gpio_func_uart = 0d2;
const gpio_func_i2c = 0d3;
const gpio_func_pwm = 0d4;
const gpio_func_sio = 0d5;
const gpio_func_pio0 = 0d6;
const gpio_func_pio1 = 0d7;
const gpio_func_pio = [ gpio_func_pio0, gpio_func_pio1 ];
const gpio_func_clock = 0d8;
const gpio_func_usb = 0d9;
const gpio_func_null = 0d31;

const GPIO_IRQ_EDGE_FALL = 0x4;
const GPIO_IRQ_EDGE_RISE = 0x8;
const NUM_BANK0_GPIOS = 0d30;

const PADS_BANK0_GPIO_IE_BITS = 0x00000040;
const PADS_BANK0_GPIO_OD_BITS = 0x00000080;

place struct {
    struct {
        uint32 status;
        uint32 ctrl;
        }[NUM_BANK0_GPIOS] gpio;
    uint32[4]@0x0f0 intr;
    struct {
        uint32[4] inte;
        uint32[4] intf;
        uint32[4] ints;
        }[2]@0x100 proc;
    struct {
        uint32[4] inte;
        uint32[4] intf;
        uint32[4] ints;
        } dormant_wake;
    } @x40014000 io_bank0;

place struct {
    uint32 voltage_select;
    uint32[NUM_BANK0_GPIOS] gpio;
    uint32 swclk;
    uint32 swd;
    } @x4001c000 pads_bank0;

fun gpio_set_direction(gpio, dir) {

    if (dir) {
        poke sio_hw.gpio_oe.set, 0x1 << gpio;
    }
    else {
        poke sio_hw.gpio_oe.clr, 0x1 << gpio;
    }
}

fun gpio_put(gpio, value) {

    if (value) {
        poke sio_hw.gpio_out.set, 0x1 << gpio;
    }
    else {
        poke sio_hw.gpio_out.clr, 0x1 << gpio;
    }
}

fun gpio_get(gpio) {
    return ((peek(sio_hw.gpio_in) >> gpio) & 0x1) == 0x1;
}

fun gpio_init(gpio) {
    gpio_set_direction(gpio, GPIO_IN);
    gpio_put(gpio, false);
    gpio_set_function(gpio, gpio_func_sio);
}

fun gpio_set_function(gpio, function) {

    // Set input enable on, output disable off
    reg_write_masked(pads_bank0.gpio[gpio], 
                 PADS_BANK0_GPIO_IE_BITS, PADS_BANK0_GPIO_IE_BITS | PADS_BANK0_GPIO_OD_BITS);

    poke io_bank0.gpio[gpio].ctrl, function;
}

fun gpio_acknowledge_irq(gpio, events) {

    poke io_bank0.intr[(gpio / 0d8)], events << (0d4 * (gpio % 0d8));
}

var struct {
    irq_routine;
    pinned_routine;
    }[2] gpio_handlers;

fun gpio_set_irq_routine(response) {
    const core = coreNum();
    const GPIO_IRQ_CALLBACK_ORDER_PRIORITY = 0d0;

    fun irq_response() {
        for (var gpio = 0d0; gpio < NUM_BANK0_GPIOS; gpio= gpio + 0d8) {
            var events8 = peek(io_bank0.proc[core].ints[gpio >> 0d3]);
        
            for(var i = gpio; (events8 != 0d0) and (i < (gpio + 0d8)); i = i + 0d1) {
                var events = events8 & 0xf;
                if (events != 0d0) {
                    gpio_acknowledge_irq(i, events);
                    response(i, events);
                }
                events8 = events8 >> 0d4;
            }
        }
    }

    fun setup_routine() {
        if (response) {
            gpio_handlers[core].irq_routine = make_routine(irq_response, true);
            gpio_handlers[core].pinned_routine = pin(gpio_handlers[core].irq_routine);
            irq_add_shared_handler(io_irq_bank0, gpio_handlers[core].pinned_routine, GPIO_IRQ_CALLBACK_ORDER_PRIORITY);
        }
    }

    if (!gpio_handlers[core].pinned_routine) {
        setup_routine();
    } else {
        irq_remove_handler(io_irq_bank0, gpio_handlers[core].pinned_routine);
        gpio_handlers[core].pinned_routine = nil;
        gpio_handlers[core].irq_routine = nil;
        setup_routine();
    }
}

fun gpio_set_irq_enabled(gpio, events, enabled) {
    gpio_acknowledge_irq(gpio, events);

    events = events << (0d4 * (gpio % 0d8));

    if (enabled) {
        poke io_bank0.proc[coreNum()].inte[gpio >> 0d3], REG_ALIAS_SET_BITS, events;
    }
    else {
        poke io_bank0.proc[coreNum()].inte[gpio >> 0d3], REG_ALIAS_CLR_BITS, events;
    }
}

