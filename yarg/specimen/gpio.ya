import("machine");
import("irq");

const pico_led = 0d25;

const GPIO_OUT = true;
const GPIO_IN = false;
const GPIO_FUNC_SIO = 0d5;
const GPIO_IRQ_EDGE_FALL = 0x4;
const GPIO_IRQ_EDGE_RISE = 0x8;
const GPIO_IRQ_CALLBACK_ORDER_PRIORITY = 0d0;
const NUM_BANK0_GPIOS = 0d30;

const PADS_BANK0_GPIO0_IE_BITS = 0x00000040;
const PADS_BANK0_GPIO0_OD_BITS = 0x00000080;
const PADS_BANK0_GPIO0_ISO_BITS = 0x00000100;

var any[2] callbacks;

const sio_hw_gpio_out = sio_hw_base + 0x10;
const sio_hw_gpio_oe  = sio_hw_base + 0x20;

const REG_ALIAS_RW_BITS  = 0x0 << 0d12;
const REG_ALIAS_XOR_BITS = 0x1 << 0d12;
const REG_ALIAS_SET_BITS = 0x2 << 0d12;
const REG_ALIAS_CLR_BITS = 0x3 << 0d12;

class alias_reg {
    read() { return rpeek(this.rw_reg); }
    write(val) { rpoke(this.rw_reg, val); }
    write_masked(val, mask) { this.xor((this.read() ^ val) & mask); }
    set(mask) { rpoke(this.set_reg, mask); }
    clr(mask) { rpoke(this.clr_reg, mask); }
    xor(mask) { rpoke(this.xor_reg, mask); }
}

class alias_reg4K < alias_reg {
    init(addr) {
        place muint32 addr + REG_ALIAS_RW_BITS read_write;
        this.rw_reg = read_write;
        place muint32 addr + REG_ALIAS_SET_BITS set;
        this.set_reg = set;
        place muint32 addr + REG_ALIAS_CLR_BITS clr;
        this.clr_reg = clr;
        place muint32 addr + REG_ALIAS_XOR_BITS xor;
        this.xor_reg = xor;
    }
}

class alias_reg4 < alias_reg {
    init(addr) {
        place muint32 addr read_write;
        this.rw_reg = read_write;
        place muint32 addr + 0x4 set;
        this.set_reg = set;
        place muint32 addr + 0x8 clr;
        this.clr_reg = clr;
        place muint32 addr + 0x12 xor;
        this.xor_reg = xor;
    }
}

fun gpio_set_direction(gpio, dir) {
    var ctrl = alias_reg4(sio_hw_gpio_oe);

    if (dir) {
        ctrl.set(0x1 << gpio);
    }
    else {
        ctrl.clr(0x1 << gpio);
    }
}

fun gpio_put(gpio, value) {
    var ctrl = alias_reg4(sio_hw_gpio_out);

    if (value) {
        ctrl.set(0x1 << gpio);
    }
    else {
        ctrl.clr(0x1 << gpio);
    }
}

fun gpio_init(gpio) {
    gpio_set_direction(gpio, GPIO_IN);
    gpio_put(gpio, false);
    gpio_set_function(gpio, GPIO_FUNC_SIO);
}

fun gpio_set_function(gpio, function) {

    const pads_bank_0_pin_offset = 0d4 + 0d4 * gpio;
    var pinctrl = alias_reg4K(PADS_BANK0_BASE + pads_bank_0_pin_offset);

    // Set input enable on, output disable off
    pinctrl.write_masked(PADS_BANK0_GPIO0_IE_BITS, PADS_BANK0_GPIO0_IE_BITS | PADS_BANK0_GPIO0_OD_BITS);

    // Zero all fields apart from fsel; we want this IO to do what the peripheral tells it.
    // This doesn't affect e.g. pullup/pulldown, as these are in pad controls.
    const ctrl_offset = (0d8 * gpio) + 0d4;
    var hw_ctrl = alias_reg4K(IO_BANK0_BASE + ctrl_offset);
    hw_ctrl.write(function);
}

fun gpio_acknowledge_irq(gpio, events) {
    var register_base = IO_BANK0_BASE;
    register_base = register_base + 0d30 * 0d8;
    const offset = (gpio / 0d8) * 0d4;
    place muint32 register_base + offset reg;

    rpoke(reg, events << (0d4 * (gpio % 0d8)));
}

fun gpio_default_irq_handler() {
    const core = coreNum();
    const callback = callbacks[core];

    var register_base = IO_BANK0_BASE;
    register_base = register_base + 0d30 * 0d8;
    register_base = register_base + 0d4 * 0d4;
    register_base = register_base + core * 0d4 * 0d3 *0d4;
    register_base = register_base + 0d2 * 0d4 * 0d4;

    for (var gpio = 0d0; gpio < NUM_BANK0_GPIOS; gpio= gpio + 0d8) {
        const gpio_bank = gpio >> 0d3;
        place muint32 register_base + gpio_bank * 0d4 register_location;

        var events8 = rpeek(register_location);
      
        for(var i = gpio; (events8 != 0d0) and (i < (gpio + 0d8)); i = i + 0d1) {
            var events = events8 & 0xf;
            if (events != 0d0) {
                gpio_acknowledge_irq(i, events);
                if (callback) {
                    callback(i, events);
                }
            }
            events8 = events8 >> 0d4;
        }
    }
}

var gpio_handler_routine;
var pinned_gpio_handler_routine;

fun gpio_set_irq_callback(callback) {
    const core = coreNum();

    if (!gpio_handler_routine) {
        gpio_handler_routine = make_routine(gpio_default_irq_handler, true);
        pinned_gpio_handler_routine = pin(gpio_handler_routine);
    }
    
    if (callbacks[core]) {
        if (!callback) {
            irq_remove_handler(IO_IRQ_BANK0, pinned_gpio_handler_routine);
        }
        callbacks[core] = callback;
    } else if (callback) {
        callbacks[core] = callback;
        irq_add_shared_handler(IO_IRQ_BANK0, pinned_gpio_handler_routine, GPIO_IRQ_CALLBACK_ORDER_PRIORITY);
    }
}

fun gpio_set_irq_enabled(gpio, events, enabled) {
    gpio_acknowledge_irq(gpio, events);

    events = events << (0d4 * (gpio % 0d8));
    var ctrl = alias_reg4K(0x40014100);

    if (enabled) {
        ctrl.set(events);
    }
    else {
        ctrl.clr(events);
    }
}

fun gpio_set_irq_enabled_with_callback(gpio, events, enabled, callback) {
    gpio_set_irq_callback(callback);
    gpio_set_irq_enabled(gpio, events, enabled);
    if (enabled) {
        irq_set_enabled(IO_IRQ_BANK0, true);
    }
}
