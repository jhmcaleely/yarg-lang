# yarg-lang

Yarg-Lang is a project to experiment with a dynamic language targetting microcontrollers. It has not yet made a release suitable for wide use.

Yarg aims to be a dedicated language for Microcontroller firmware development. It offers:

  - An interactive, on-device, REPL
  - Direct hardware access
  - Interupt based and multi-core multiprocessing
  - Many other modern language conveniences.

Microcontrollers (such as the $4 Raspberry Pi Pico, or the ESP32 family) are powerful computers, yet we commonly develop software for them with languages like C that were designed when resources were far more scarce. Yarg aims to provide a richer language, spending some of these resources to achive that. Of course, if you want to use modern language features, many general purpose languages are available in 'Micro', 'Tiny' or other cut-down versions of their implementation for microcontroller use. These implementations are faced with choices when the resources available do not support the same implementation possible in their original general purpose implementation. Do they try to be compatible (but over-expensive), or do they document a limitation compared to the full language implementation? Yarg aims to remove the limitations these choices impose, and offer modern langauge features, by being dedicated to the task of Microcontroller development.

Many samples for starting projects include polling, (while 'true'; sleep(x); do-stuff;), which can be wasteful of energy. How long is x? Modern microprocessors are designed to be normally off, and to wake when something interesting is happening. Yarg is a language designed with this in mind from the start.

## Aims

  - A dynamic environment for on-device prototyping
  - Tooling to deploy working prototypes
  - Sufficient static typing to reasonably add device specific code without writing C
  - Interop with C libraries available on device

Not (yet) intended for use. Additional documentation on the [wiki][wiki]

[wiki]: https://github.com/jhmcaleely/yarg-lang/wiki

| dir | Description |
| :--- | :--- |
| `cyarg/` | yarg implementation in C |
| `hostyarg/` | host tooling for yarg maintenance |
| `tools/` | Miscellaneous tools |
| `vscode-yarg/` | A VS Code Language Extension for Yarg |
| `yarg/specimen/` | Samples of Yarg |
| `yarg/specimen/conway-life-display` | A Yarg implemention of: [jhmcaleely/conway-life-display](https://github.com/jhmcaleely/conway-life-display) |
| `yarg/specimen/todo` | Things that don't work yet |
| `yarg/test/` | A Test Suite |

## Samples

These two samples illustrate Yarg:
  * `hello_led` can be typed at the REPL after boot, and directly manipulates registers as needed. 
  * `hello_button` uses Yarg channels (similar to go channels) to signal when an interrupt is generated by a button. The CPU can simply wait indefinately at idle for each button press.

### Hello LED

This sample turns on the builtin LED for a Pico, manipulating the registers directly.

`yarg/specimen/hello_led.ya`:
```
// the memory locations we need, see rp2040 datasheet: 
// https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf

const NUM_BANK0_GPIOS = 30;

place struct {
    muint32@0x014 gpio_out_set;
    muint32@0x024 gpio_oe_set;
    } 0xd0000000 sio_hw;

place struct {
    struct {
        muint32 status;
        muint32 ctrl;
        }[NUM_BANK0_GPIOS] gpio;
    } 0x40014000 io_bank0;

// the built in LED on a Pico.
const pico_led = 0d25;
const gpio_field = 0x1 << pico_led;

// minimally configure a GPIO, assuming core was reset first.
const GPIO_FUNC_SIO = 0d5;

poke io_bank0.gpio[pico_led].ctrl, GPIO_FUNC_SIO;
poke sio_hw.gpio_oe_set, gpio_field;


// turn the LED on.
poke sio_hw.gpio_out_set, gpio_field;
```

### Button Press

This sample creates a function that checks the events for the specified GPIO, and signals those on a channel the main coroutine can wait on.

Uses the 'gpio' library, which captures the direct register code above in a library of functions.

Assumes a button is wired to GPIO 2, and a LED+Resistor are connected to GPIO 3.

`yarg/specimen/hello_button.ya`:
``` 
import("gpio");

fun button_callback(gpio, chan) {

    const core = coreNum();

    fun gpio_callback() {
        const events8 = peek(io_bank0.proc[core].ints[gpio >> 0d3]);
        const events = events8 >> (0d4 * (gpio % 0d8));

        // acknowledge the irq to the peripheral, and signal the requesting routine.
        gpio_acknowledge_irq(gpio, events);
        share(chan, events);
    }

    return gpio_callback;
}

// intialise a GPIO for an LED.
const led_io = 0d3;
gpio_init(led_io);
gpio_set_direction(led_io, GPIO_OUT);

// set up the callback as an address we can install in the IRQ peripheral
const button_io = 0d2;
var button_channel = make_channel();
var button_handler_routine = make_routine(button_callback(button_io, button_channel), true);
var button_handler_address = pin(button_handler_routine);

gpio_init(button_io);
irq_add_shared_handler(IO_IRQ_BANK0, button_handler_address, 0d0);

// enable interrupts for this gpio
gpio_set_irq_enabled(button_io, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);
irq_set_enabled(IO_IRQ_BANK0, true);


bool state;
while (true) {
    var events = receive(button_channel);
    state = !state;
    gpio_put(led_io, state);
}
```

## Name

[Cornish Yarg](https://en.wikipedia.org/wiki/Cornish_Yarg) is a cheese I enjoy.
